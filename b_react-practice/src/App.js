import React, { useState } from "react";

function App() {
  const [serialPort, setSerialPort] = useState(null);
  const [logs, setLogs] = useState([]);

  const log = (msg) => {
    console.log(msg);
    setLogs((prev) => [...prev, msg]);
  };

  const commands = [
    new Uint8Array([0, 0x92, 0, 0]),
    new Uint8Array([
      0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x00, 0x00, 0x05, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x0a, 0x00,
      0x26, 0x00, 0x0f, 0x00, 0x30, 0x00, 0x14, 0x00, 0x39, 0x00, 0x19, 0x00,
      0x43, 0x00, 0x1e, 0x00, 0x56, 0x00, 0x28, 0x00, 0x69, 0x00, 0x32, 0x00,
      0x7c, 0x00, 0x3c, 0x00, 0x8f, 0x00, 0x46, 0x00, 0x07, 0x00, 0x0a, 0x00,
    ]),
    new Uint8Array([
      0x00, 0x90, 0x01, 0x00, 0x00, 0x00, 0x1d, 0x00, 0x0a, 0x00, 0x30, 0x00,
      0x14, 0x00, 0x43, 0x00, 0x1e, 0x00, 0x56, 0x00, 0x28, 0x00, 0x69, 0x00,
      0x32, 0x00, 0x7c, 0x00, 0x3c, 0x00, 0x8f, 0x00, 0x46, 0x00, 0xb5, 0x00,
      0x5a, 0x00, 0xc8, 0x00, 0x64, 0x00, 0xfa, 0x00, 0x06, 0x00, 0x1c, 0x02,
      0x28, 0x00, 0xca, 0x01, 0x2d, 0x00, 0xde, 0x00, 0x41, 0x00, 0x78, 0x00,
    ]),
    new Uint8Array([
      0x00, 0x90, 0x02, 0x00, 0x55, 0x00, 0x5d, 0x00, 0x5a, 0x00, 0x50, 0x00,
      0x5f, 0x00, 0x46, 0x00, 0x64, 0x00, 0x3c, 0x00, 0x69, 0x00, 0x35, 0x00,
      0x6e, 0x00, 0x2e, 0x00, 0x73, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
      0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5c, 0x00, 0xf5, 0x01, 0x0a, 0x00,
      0xff, 0xff, 0x0a, 0x00, 0xff, 0xff, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]),
    new Uint8Array([
      0x00, 0x90, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x02, 0x00,
      0x19, 0x00, 0x1d, 0x01, 0xb9, 0x00, 0x0a, 0x00, 0x26, 0x02, 0xc2, 0x01,
      0x05, 0x00, 0xff, 0xff, 0x0a, 0x00, 0x1e, 0x00, 0x2c, 0x01, 0xf4, 0x01,
    ]),
    new Uint8Array([
      0x00, 0x90, 0x04, 0x00, 0xf4, 0x01, 0x01, 0x00, 0x08, 0x00, 0x08, 0x00,
      0x05, 0x00, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x1e, 0x00,
      0x32, 0x00, 0x0a, 0x00, 0x0f, 0x00, 0x0a, 0x00, 0x07, 0x00, 0x0a, 0x00,
      0xff, 0xff, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00,
      0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0xff, 0xff, 0x1e, 0x00,
    ]),
    new Uint8Array([
      0x00, 0x90, 0x05, 0x00, 0x14, 0x00, 0x0a, 0x00, 0x03, 0x00, 0x23, 0x00,
      0x01, 0x00, 0x0a, 0x00, 0x64, 0x00, 0x91, 0x00, 0x0e, 0x01, 0x14, 0x00,
      0x00, 0x00, 0x10, 0x0e, 0x20, 0x1c, 0xa0, 0x0f, 0x00, 0x00, 0x00, 0x00,
      0x07, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x05, 0x00, 0x08, 0x00, 0x06, 0x00,
    ]),
    new Uint8Array([
      0x00, 0x90, 0x06, 0x40, 0x0b, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
    ]),
    // add all other commands similarly
  ];

  const connectPort = async () => {
    try {
      const filters = [{ usbVendorId: 0x0483, usbProductId: 0x5740 }];

      // Check for already connected ports
      const existingPorts = await navigator.serial.getPorts();
      const stm32Ports = existingPorts.filter(
        (port) =>
          port.getInfo().usbVendorId === 0x0483 &&
          port.getInfo().usbProductId === 0x5740,
      );

      if (stm32Ports.length > 1) {
        alert("Multiple STM32 devices detected. Connect only ONE controller.");
        return;
      }

      const port =
        stm32Ports[0] || (await navigator.serial.requestPort({ filters }));
      await port.open({ baudRate: 115200 });
      setSerialPort(port);
      log("Port Connected Successfully");
    } catch (error) {
      log("Failed to connect port: " + error.message);
      alert(error.message);
    }
  };

  const sendCommands = async () => {
    if (!serialPort) {
      alert("Port not connected!");
      return;
    }

    try {
      for (let idx = 0; idx < commands.length; idx++) {
        const cmd = commands[idx];
        log(`\nSending command ${idx + 1}...`);

        // ---------- SEND COMMAND ----------
        const writer = serialPort.writable.getWriter();
        // Convert command to hex string for logging
        const hexCmd = Array.from(cmd)
          .map((b) => `0x${b.toString(16).padStart(2, "0")}`)
          .join(", ");

        log(`Sending command ${idx + 1}: ${hexCmd}`);
        await writer.write(cmd);
        writer.releaseLock();
        log(`Sent command ${idx + 1}...`);

        // Small delay between commands (important for MCU)
        await new Promise((r) => setTimeout(r, 2000));

        // ---------- READ RESPONSE UNTIL IDLE ----------
        const reader = serialPort.readable.getReader();
        const response = [];
        const idleTimeout = 1000; // 1 second idle
        let lastDataTime = Date.now();

        try {
          while (true) {
            // Stop if idle timeout exceeded
            if (Date.now() - lastDataTime > idleTimeout) break;

            // Try reading, but timeout after 50ms if no data
            const { value, done } = await Promise.race([
              reader.read(),
              new Promise((resolve) =>
                setTimeout(() => resolve({ value: null, done: false }), 50),
              ),
            ]);

            if (done) break;

            if (value && value.length > 0) {
              response.push(...value);
              lastDataTime = Date.now(); // reset idle timer
            }
          }
        } finally {
          reader.releaseLock();
        }

        // ---------- PRINT RESPONSE ----------
        if (response.length > 0) {
          const hex = Array.from(response)
            .map((b) => `0x${b.toString(16).padStart(2, "0")}`)
            .join(", ");
          log(`Response: ${hex}`);
        } else {
          log("No response");
        }

        // Small delay between commands (important for MCU)
        await new Promise((r) => setTimeout(r, 2000));
      }

      log("All commands sent!");
    } catch (err) {
      log("Error sending commands: " + err.message);
    }
  };

  const disconnectPort = async () => {
    if (serialPort) {
      await serialPort.close();
      setSerialPort(null);
      log("Port disconnected");
    }
  };

  return (
    <div className="App">
      <h1>STM32 Serial Test</h1>
      <button onClick={connectPort}>Connect Port</button>
      <button onClick={sendCommands} disabled={!serialPort}>
        Send Commands
      </button>
      <button onClick={disconnectPort} disabled={!serialPort}>
        Disconnect
      </button>
      <pre style={{ whiteSpace: "pre-wrap", marginTop: "20px" }}>
        {logs.join("\n")}
      </pre>
    </div>
  );
}

export default App;

// Sending command 6:

// 0x00, 0x90, 0x04, 0x00, 0xf4, 0x01, 0x01, 0x00, 0x08, 0x00, 0x08, 0x00, 0x05, 0x00, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x32, 0x00, 0x0a, 0x00, 0x0f, 0x00, 0x0a, 0x00, 0x07, 0x00, 0x0a, 0x00, 0xff, 0xff, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0x0a, 0x00, 0xff, 0xff, 0x1e, 0x00
