<!-- 
 
1️⃣ MongoDB Fundamentals (Must-Know)

What is MongoDB and why use it?

Difference between SQL vs MongoDB

What is a document and a collection?

BSON vs JSON

What is _id? Can we customize it?

Data types supported in MongoDB

What is a schema-less database?

When should you NOT use MongoDB?

What is replication?

MongoDB vs MySQL (use cases)

2️⃣ Schema Design (Very Important 🔥)

Embedded documents vs References

When to embed and when to reference?

One-to-many relationship design

Many-to-many relationship

Schema design for large datasets

Handling optional fields

Anti-patterns in MongoDB schema

Designing for read vs write heavy apps

Document size limit (16MB) – how to handle?

Versioning MongoDB schemas

3️⃣ Indexing & Performance (Advanced 🔥)

What is an index?

Types of indexes:

Single field

Compound

Multikey

Text

Hashed

TTL

How indexes improve performance?

Downsides of indexes

Index selectivity

Covered queries

Explain explain() output

Indexing on embedded fields

When indexes are not used?

Slow query optimization

4️⃣ CRUD Operations (Deep Knowledge)

Difference between insertOne vs insertMany

updateOne vs updateMany

replaceOne vs update

$set, $unset, $push, $pull

Atomic updates

Upserts

Bulk operations

Transactions vs atomicity

Find vs Aggregate

Pagination methods (skip/limit vs cursor)

5️⃣ Aggregation Framework (🔥 Very Important)

What is aggregation?

Aggregation vs Map-Reduce

Common stages:

$match

$group

$project

$sort

$lookup

$unwind

$facet

$lookup performance impact

Pipeline optimization

Aggregation indexes usage

$expr usage

Handling large aggregations

Real-world aggregation example

Aggregation vs SQL JOIN

6️⃣ Transactions & Concurrency (Advanced)

What are MongoDB transactions?

Single-document atomicity

Multi-document transactions

ACID support in MongoDB

Read & Write concerns

Isolation levels

Locking mechanism

Optimistic concurrency control

Handling race conditions

Transaction performance tradeoffs

7️⃣ Replication & High Availability

What is a replica set?

Primary vs Secondary

Election process

Failover handling

Read preferences

Write concern levels

Replication lag

Hidden members

Arbiter usage

Monitoring replication health

8️⃣ Sharding & Scalability (🔥 Advanced)

What is sharding?

Shard key selection

Hashed vs ranged shard key

Chunk migration

Balancer role

Hot shard problem

Scatter-gather queries

Zone sharding

Resharding

Sharding best practices

9️⃣ Security & Best Practices

MongoDB authentication methods

Role-based access control

Data encryption (at rest & in transit)

IP whitelisting

Preventing NoSQL injection

Secure connection string

Secrets management

Backup strategies

Point-in-time recovery

Auditing

🔟 Mongoose (Node.js Integration)

Mongoose vs Native driver

Schema & model

Middleware (pre/post hooks)

Validation vs business logic

Populate – how it works internally?

Lean queries

Virtuals

Transactions in Mongoose

Handling large collections

Performance pitfalls in Mongoose

🔥 Real-World Scenario Questions

Collection has 100M documents – how to optimize?

Queries slow after data growth – what steps?

Frequent writes causing performance issues

Data duplication vs performance – how to decide?

MongoDB CPU usage high – debugging steps

Handling soft deletes

Designing audit logs

Multi-tenant schema design

Migrating schema without downtime

MongoDB backup & restore strategy

-->