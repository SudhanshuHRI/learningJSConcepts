<!-- 

1️⃣ React Core (Must-Know)

What is React and why is it used?

Virtual DOM vs Real DOM

JSX – how does it work internally?

Controlled vs Uncontrolled components

Props vs State

Lifting state up

One-way data binding

Key prop – why is it important?

Fragment vs <div>

React component lifecycle (class vs hooks)

2️⃣ Hooks (Very Important)

useState – batching and async updates

useEffect – dependency array deep dive

Cleanup function in useEffect

useRef vs useState

useMemo vs useCallback

Custom hooks – when & how

Rules of hooks

useLayoutEffect vs useEffect

useReducer – when to use it

Common mistakes with hooks

3️⃣ State Management (Advanced)

Prop drilling – solutions

Context API – when NOT to use it

Redux vs Context

Redux Toolkit advantages

Redux middleware (thunk, saga)

Zustand / Recoil comparison

Global vs local state

Normalizing state shape

Immutable updates

Handling large state trees

4️⃣ Rendering & Performance (🔥 Very Important)

Reconciliation algorithm

How React decides to re-render

React.memo – when it helps

Avoiding unnecessary re-renders

Code splitting & lazy loading

Suspense – how it works

Virtualization (large lists)

Why keys should not be index

Debouncing & throttling in React

Performance profiling tools

5️⃣ Advanced React Concepts

Higher Order Components (HOC)

Render props

Compound components

Portals – real use cases

Error Boundaries

Forward refs

Controlled re-rendering

Strict Mode – why double render?

Concurrent rendering (React 18)

Server Components (overview)

6️⃣ React 18 & Modern Features

Automatic batching

useTransition

useDeferredValue

Streaming SSR

Client vs Server Components

Hydration

Why React 18 changed rendering

createRoot vs render

Suspense for data fetching

Future of React

7️⃣ Forms & Validation

Controlled forms

Formik vs React Hook Form

Validation strategies

Handling large forms

Dynamic form fields

File uploads

Debounced validations

Accessibility in forms

Error handling UX

Multi-step forms

8️⃣ Routing & API Integration

React Router – core concepts

Protected routes

Lazy loaded routes

Query params vs params

API calls – axios vs fetch

Error handling in APIs

Retry & fallback logic

Pagination & infinite scroll

Canceling API requests

Optimistic UI updates

9️⃣ Testing (Important for Product Companies)

Unit vs Integration testing

Jest basics

React Testing Library

Mocking API calls

Snapshot testing – pros/cons

Testing hooks

Testing async components

Code coverage

E2E testing (Cypress)

Test best practices

🔟 Architecture & Folder Structure

Feature-based folder structure

Atomic design

Reusable components

Separation of concerns

Environment configs

Handling constants

Scalable CSS strategy

Monorepo basics

Design system integration

Micro-frontend basics

1️⃣1️⃣ Security & Best Practices

XSS prevention in React

Secure storage (tokens)

CSRF handling

Role-based access control

Environment variables

Protecting routes

Third-party script risks

Content Security Policy

Dependency vulnerabilities

Secure file uploads

1️⃣2️⃣ Real Interview Scenario Questions

App is slow – how do you debug?

Component re-renders too often – fix it

Large list performance issue

API fails intermittently – UX handling

Form with 100+ fields – design

State syncing issues

Memory leaks in React

White screen in production

SEO issues in React app

Explain a tough bug you solved

-->